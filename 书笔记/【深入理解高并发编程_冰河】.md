（这本书挺好的，还是彩色版，可以收藏）

- [第2章 并发编码概述](#第2章-并发编码概述)
  - [2.1.2 进程与线程](#212-进程与线程)
  - [2.1.3 线程组](#213-线程组)
  - [2.1.4守护线程](#214守护线程)
- [第4章 并发编程的本质问题](#第4章-并发编程的本质问题)
  - [4.2.3 Java中的原子性问题](#423-java中的原子性问题)
  - [4.3 Java中的可见性问题](#43-java中的可见性问题)
  - [4.4 Java中的有序性问题](#44-java中的有序性问题)
- [第19章 深度解密分布式锁框架](#第19章-深度解密分布式锁框架)
  - [19.5 CAP理论与分布式锁模型](#195-cap理论与分布式锁模型)
    - [19.5.2 基于Redis的AP架构](#1952-基于redis的ap架构)
    - [19.5.3 基于Zookeeper的CP架构](#1953-基于zookeeper的cp架构)
  - [19.6 基于Redis实现分布式锁](#196-基于redis实现分布式锁)




# 第2章 并发编码概述

## 2.1.2 进程与线程

1. 进程是操作系统分配资源的最小单位，线程是CPU调试的最小单元；

2. 一个进程中可以包含多个线程，一个线程只能属于一个进程；
3. 进程之间相互独立，进程内部的线程之间不完全独立，共享进程的堆内存、方法区内存；
4. 进程上下文切换慢，线程快的多；

## 2.1.3 线程组

可以将相同功能的线程放到一个线程组中。java里就是ThreadGroup。

## 2.1.4守护线程

只要有一个非守护线程还在运行，守护线程就会一直运行。只有全部的非守护线程运行结束，守护线程才会退出。





# 第4章 并发编程的本质问题

## 4.2.3 Java中的原子性问题

```java
public void increMent() {
  count++;
}
```

编译的指令大致包含三个步骤：

1. 将变量count从内存中加载到CPU的寄存器中；
2. 在CPU的寄存器执行count++操作；
3. 将count++后的结果写入缓存（可能是CPU的缓存，也可能是计算机的内存）；

CPU在执行1、2、3的过程中发生线程切换，出现问题。

解决方案：加锁、CAS操作、使用原子类。



## 4.3 Java中的可见性问题

可见性是指一个线程修改了共享变量，其他线程能够立即读取到共享变量的最新值。

有两种情况下，一定可见：

* 线程串行执行；
* 线程在单核CPU执行；

```js
--------                   -------
| 线程1 |                  | 线程2 |
--------                   -------
  |                           |
  | 读写                       | 读写
  |                           |
------------------------------------
|             单核CPU               |
|           -----------            |
|           | 共享变量  |           |
|           -----------            |
------------------------------------
                 |
                 | 数据同步
-------------------------------------
|              共享变量               |
|                                    |
|               主内存                |
--------------------------------------
```

在多核CPU上运行，就会出现可见性问题，出现的原因是CPU缓存。多核CPU中，每个CPU都有自己单独的缓存，多个线程同时运行在不同的CPU核心上，一个线程写了共享变量，另一个线程不一定能够立刻读取到。

```js
--------                   -------
| 线程1 |                  | 线程2 |
--------                   -------
  |                           |
  | 读写                       | 读写
  |                           |
-------------            -------------
| CPU-1      |           | CPU-2      |
| ---------  |           | ---------  |
|| 共享变量X ||           || 共享变量X ||
| ---------  |           | ---------  |
-------------            -------------  
                 |
                 | 数据同步
-------------------------------------
|              共享变量X               |
|                                    |
|               主内存                |
--------------------------------------
```

解决方案：volatile、内存模型Happens-Before原则。

## 4.4 Java中的有序性问题

有序性问题：计算机和编译器修改程序的执行顺序，导致出现问题。（即指令重排）

```java
// 单例问题
public class Single {
  private static SingleClass ins;
  private Single() {}
  public static Single getInstance() {
    if (ins == null) {
      synchronized(Single.class) {
        if (ins == null) {
          ins = new Single();
        }
      }
    }
    return ins;
  }
}
```

看起来没问题，但问题出在 `ins = new Single();`上，包括三个步骤：

1. 分配内存空间；
2. 初始化对象；
3. 将ins引用指向内存空间；

当CPU进行重排后，执行顺序变为1、3、2，就有问题了。

假设A线程拿到了锁，执行了1、3，此时ins有指向了，不为空，发生线程切换，B线程判断ins不为null，拿到ins去用，但此时ins还没初始化，可能出现问题。

解决方案：volatile、内存模型Happens-Before原则。





# 第19章 深度解密分布式锁框架

## 19.5 CAP理论与分布式锁模型

### 19.5.2 基于Redis的AP架构

Availability、Partition tolerance

```js
               ----------------------------
User  ------>  | 节点1 ---> 节点2 ---> 节点3 |
      <------  ----------------------------
               
向Redis的节点1写入数据后会立即返回, 之后Redis中会以异步方式同步数据。
```

缺点：线程向Redis的Master节点写入锁后，Master向Slave节点同步锁失败。此时另一个线程读取Slave节点的数据，发现没有。也就是数据同步的问题。

对此，有个红锁的方案，简单地说就是部多个Redis实例，对这批Redis加锁，当超过一半实例加锁成功则认为加锁是成功的。不过，实际应用中极少。



### 19.5.3 基于Zookeeper的CP架构

```js
               ----------------------------
User  ------>  | 节点1 ---> 节点2 ---> 节点3 |
      <------  ----------------------------
               
向节点1写入数据后后，会等待数据向节点2和节点3同步。大多数Zookeeper节点同步成功后，才向User返回结果。
```

强一致模型。



## 19.6 基于Redis实现分布式锁

1. 锁命令：SETNX key value ex 60；

2. 业务执行超过锁过期时间问题：开个单独的线程，执行异步定时任务一更新锁过期时间；

   专业术语叫：异步续命。



