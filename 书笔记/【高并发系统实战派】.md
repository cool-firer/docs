# 第1章 什么是高并发

## 1.2 高并发系统有哪些关键指标

### 1.2.1 响应时间

发出请求到收到系统完整响应数据所需的时间。

<br />

### 1.2.2 吞吐量

单位时间内系统处理的用户请求数。不同的上下文，有不同的定义。

从业务角度看，吞吐量可以用“请求数/秒”，“人数/天”，或“处理业务数/小时” 等来衡量。

从网络角度看，可以用“字节数/秒”来衡量。

<br />

### 1.2.3 QPS（每秒请求数）

预估QPS的方法：绝大部分系统在白天的请求量都比较大，所以以白天来计算QPS。依据二八原则，80%的流量是在20%的时间段内产生的。

例如，每天有5 000 000个请求，预估QPS = ( 5 000 000 * 0.8）/ （12 * 60 * 60 * 0.2）= 462 。即当前系统每天平均QPS为462，为保险起见，再预留个20%左右。

80%的流量在白天进行，所以乘以0.8。

白天12个小时，在这12个小时里有效时间为0.2，转换秒。

再得出峰值QPS，一般为平均QPS的两倍。即，峰值QPS = 2 * 平均QPS。

所有，需要部署的机器数 = 峰值QPS / 单台机器最高可承受的QPS（实际跑压测出来）。

<br />

### 1.4.2 高并发系统之分布式架构

分布式架构就是将一个系统拆分为多个独立的应用，各应用相互协作，组成一个整体，共同完成任务。

<br />

### 1.4.3 高并发系统之微服务架构

因为分之布架构的局限，所有才演进出了微服务架构。

微服务架构的问题：

1. 增加了复杂度。服务数量增加、交互模式的变更；
2. 服务边界划分是困难，不能过粗过细，需要很强的业务沉淀；
3. 保持数据一致性复杂；
4. 需要更强的运维知识；
5. 增加了开发流程的复杂性；

在微服务架构中，所有的服务都是独立部署的。当服务数量很大时，如果还是像单体应用那样进行人工部署，则效率会非常低。所以微服务架构必须要通过自动化的方式来部署。现在，持续集成及持续部署都是通用的实践了。

<br />



# 第2章 从剖析两个高并发系统开始

## 2.1 案例一：千万级流量“秒杀”系统

### 2.1.1 架构一览

```js
         --------------------------------------------------
         |   --------        -------       ------         |
 用户层   |  |   App  |      |  H5   |     |  PC  |        |  
         |   --------        --------      ------         |
         --------------------------------------------------
               
         --------------------------------------------------
         |   --------        -------       ------         |
 CDN层    |  |  CDN1 |      |  CDN2 |     | CDN3 |        |   缓存秒杀活动的静态资源文件
         |   --------        --------      ------         |
         --------------------------------------------------
         
         --------------------------------------------------
         |   --------        -------       ------         |
 SLB层    |  |  SLB1  |      |  SLB2 |     | SLB3 |       |    分发请求
         |   --------        --------      ------         |
         --------------------------------------------------
      
         --------------------------------------------------
         |   --------------        ----------              |
 服务层   |  |  秒杀交易系统  |      |  等等系统 |             |
         |   --------------        -----------             |
         --------------------------------------------------
         
         --------------------------------------------------
         |   --------        -------------      --------   |
 基础设施层|  |  数据库  |     |  消息中间件  |     | 大数据 |  |
         |   --------        -------------      --------   |
         --------------------------------------------------
         
```

### 2.1.2 动静分离方案设计

什么是静态数据：

* HTML、CSS、JS文件；
* 图片等；

可以通过代理服务器缓存静态数据，例如：浏览器本地缓存（包括App端、PC端）、CDN、Nginx、Squid、Varnish等。一级一级的缓存。

```js
         -----------------------------------
         |   --------        -------       |
         |  |   App  |      |  PC   |      |  
         |   --------        -------       |
         -----------------------------------
            ⬇️                 ⬇️
         -----------------------------------
         |   --------        -------       |
         |  |   CDN1  |      | CDN2 |      |  
         |   --------        -------       |
         -----------------------------------
            ⬇️                  ⬇️
         -----------------------------------
         |   --------        -------       |
         |  | Nginx  |      | Squid |      |  
         |   --------        -------       |
         -----------------------------------
```

<br />

页面静态化：直接缓存HTTP连接，而不是缓存数据。如，代理服务器根据请求的URL直接返回HTTP对应的响应头及响应消息体。

```js
                          -------------------
                          |    代理服务器     |
用户 ---->  URL请求  ----> |    HTTP Head     |   ---> 后端服务器  ---> DB
                          |    HTTP Body     |
                          --------------------
```

<br />

## 2.2 案例二：C2C二手电商平台的社会化治理系统

Nacos做服务注册中心。

### 3 分布式事务

目前实现分布式事务的解决方案有如下几种：

* 基于XA协议的二阶段提交； 强一致性
* 基于XA协议的三阶段提交； 强一致性
* TCC；
* 基于消息的最终一致性（BASE理念）

<br />

#### (1) XA二阶段提交

分准备阶段、提交阶段。引入事务协调者，通过它来保证各个事务被正确提交。

第一阶段，准备阶段，协调者向所有参与者发送准备指令，等待回复。参与者收到“准备”指令后，就各自进行自己的业务处理，成功则返回“准备成功”，失败则返回“准备失败”。

第二阶段，提交阶段，协调者依据各参与者的返回消息，如果都是成功，则发送”提交“指令，否则则发送”回滚“指令。



# 第3章 生产级系统框架设计的细节 

## 3.1.2 如何避免重复提交

### 1 全局唯一ID防止重复提交

1. 搭建一个全局唯一ID的服务，可以用SnowFlake；
2. 在订单确定下单页面，调用全局ID服务生成订单号；
3. 提交订单时带上订单号，请求到达订单系统，利用数据库的唯一约束；

<br />

### 2 得用"Token + Redis"机制防止重复提交

1. 订单系统提供一个发放Token的接口，同时写入Redis；

2. 在”订单确认页“中调用获取Token的接口；

3. 用户在”订单确认页“提交订单时，带上Token，给服务端校验，如果Redis有Token，是第一个请求，如果没有，则是重复请求；

   <br />

### 3.1.3 如何避免更新中的ABA问题

前端每次传数据，都要带上version，后端服务每次update时都带上version判断即可。











