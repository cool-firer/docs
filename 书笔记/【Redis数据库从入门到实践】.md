作者：陈逸怀、刘勇、刘瑜、王玮

2023年5月第一版  实际写于2022年3月。



# 第2章 字符串、列表命令

String值最大长度不超过521MB。

set key value EX 过期时间秒 NX(不存在时设置)。

lpush key value1 value2 value3  => 得到 value3、value2、value1。



# 第5章 磁盘持久化

**RDB持久化**

save 900 1 ：代表如果900s内至少有1个key被改变，则触发持久化。

客户端可以 用bgsave、save来触发。



**AOF持久化**

通过appendfsync no

* no：不执行fsync，由操作系统保证数据同步到磁盘，速度最快；
* always：每次写入key都执行fsync；
* everysec：每秒fsync一次，可能会丢失1s的数据；



# 第7章事务与Lua脚本

Redis数据库提供的事务只有两个保证：

1、隔离性。不会被其他客户端发来的命令打断。

2、原子性。所有命令要么都执行，要么都不执行。有个前提是：执行命令没有错误，如果有错误，不会全部取消，只能说是部分原子。



# 第8章 缓存

**缓存穿透：**访问的数据在redis、DB都不存在，每次请求都打到DB。

解决：

1. redis里设置一个空的值;
2. 用布隆过滤器；



**缓存雪崩：**大量的缓存数据失效，请求直接打到DB。

一般有两种情况下大量缓存失效，一是数据过期时间一样的，另一种是在集群里的某个redis节点挂了，请求被分发到其他节点，其他节点扛不住也挂了，这样导致节点一个个挂。

解决：

1. 第一种情况容易，key设置随机时间。
2. 第二种的话就只能多加几个节点，用Sentinel、Cluster保证高可用。



**缓存击穿：**瞬间出现高并发流量，此时数据还没有在Redis中预热，导致请求打到了DB。

解决：

1. 用分布式锁，在Redis里数据还没准备好的情况下，同一时间只允许一个请求到DB。

